# Метод isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False. 

# from curses.ascii import isdigit

# n = input()

# for i in n:
#     if not i.isdigit(): 
#         print(i)

# a = [1, 2, 3]
# b = a.copy() #так же поможет

# b.append(4) # добавим элемент в конец
# a.pop(1) # удлаяет индекс лушче не делать если середине
# a.insert(1, 44) #вставить в первый индекст число 44
# a.reverse - перевернуть
# a.sort - отсортировать
# a.iscard  - удалить элемент по значению
# a.pop - удалить по индексу
# a.insert - вставить индекст
# a.cout - посчитает сколько раз входит в этот список
# a.copy - скопирует список
# a.clear - удалить из списка
# a.index - получить индекс элемента который передали
# a.extent - в конце списка добавляем элементы второго
# print(f'{a}') # только для изменяемыз данных: множества, словари, списки
# print(f'{b}')

# def f(a):
#     a.append(55)

# f(b)
# print(b)

# КОРТЕЖ нужен, когда нужен будет составной ключ в словаре

#a = tuple() # пустой кортеж, не изменяемый список. мы можем только создать
#a = (1, 2, 3,4)

# МНОЖЕСТВА - можно положить только не изменяемый обьект
# a = set()
# чтоб добавить элемент в множества, мы должны написать a.ddd()
# a.add(22)
# a.add(22)
# a.add(22)
# a.add(5)
# a.add(5)
# a.add(13)

# print(a) # {13, 5, 22} ответ (все экземпляры хранятся в одном, даже если 22 3 раза будет 1 раз)

# for n in range(10, 105, 7): #
#     a.add(n)
#     print(a)
# Ответ: (цырф в разброс, не узнаем что достанем)
# {10}
# {17, 10}
# {24, 17, 10}
# {24, 17, 10, 31}
# {38, 10, 17, 24, 31}
# {38, 10, 45, 17, 24, 31}
# {38, 10, 45, 17, 52, 24, 31}
# {38, 10, 45, 17, 52, 24, 59, 31}
# {66, 38, 10, 45, 17, 52, 24, 59, 31}
# {66, 38, 73, 10, 45, 17, 52, 24, 59, 31}
# {66, 38, 73, 10, 45, 80, 17, 52, 24, 59, 31}
# {66, 38, 73, 10, 45, 80, 17, 52, 87, 24, 59, 31}
# {66, 38, 73, 10, 45, 80, 17, 52, 87, 24, 59, 94, 31}
# {66, 101, 38, 73, 10, 45, 80, 17, 52, 87, 24, 59, 94, 31}

# a = set()
# b = 7

# a.add(3.5) 
# a.add(b)
# print(a) #Выводим множество

# Если мы хотим добавить список в кортеж
# a = {1, 2, 3, 5, 8}
# lst = ['3', 'Пики'] 

# a.add(tuple(lst)) # если обвернем в tuple то все заработает
# print(a) # из списка создаем не изменяемый кортеж
# # {1, 2, 3, 5, ('3', 'Пики'), 8}
# МНОЖЕСТВА НУЖНЫ когда надо что-то найти в большое кол-во элементов и если часто будут запросы от пользователя (в спиках долго) или словарях

## СЛОВАРИ (dict) - это множества, каждому элементу которого соотвествует какой-то обьект (есть ключ значение)
# непорядочнная коллекция произвольных обьектов с доступом по ключу. 
"""
dct = {}
dct[123] = [444, 213, 234] # добавялем значения в словарь
dct[(22, 44)] = ['sadasdsa', 'sadad'] # ключем может быть только не изменяемый обьект
dct[True] = False # ключем так же и в мглжестве мб try  
print(dct)

dct[True] = 6666
print(dct)
print(dct[True]) # без add просто выводим (можно вызвать)
"""
# Ответ: 
# # {123: [444, 213, 234], (22, 44): ['sadasdsa', 'sadad'], True: False}
# {123: [444, 213, 234], (22, 44): ['sadasdsa', 'sadad'], True: 6666}
# 6666
# очередность ключа соотествует очередности их добавления

## Пример:
# a = ['moskva', 'piter', 'penza'] # допустим есть список, он их сам пронумеровал, 0 1 2

# 'moskva' - 495,
# 'piter' - 812,
# 'penza' - 8412
# для таких ассоциацый в питоне есть "Словарь"
# как написать. 
# Первый способ: 
"""
d = {
    'moskva': - 495,
    'piter': - 812,
    'penza': - 8412
}
print(d) # {'moskva': -495, 'piter': -812, 'penza': -8412}
"""
# Второй способ:
"""
r = dict(moskva=495, piter=812, penza=8412) #только строки в ключах можно использовать
print(r)

# Есть еще один способ(вложенный список):
c = [['moskva',495], ['piter',812], ['penza',8412]]
t = dict(c)
q = dict.fromkeys(['a', 'b', 'c'], 100) # каждому списку нашего элемента прислваивает ключ. Через , укажем значение по умолчанию допустим 100/ каждому ключу будет присвоено это значение
print(t)
print(t)
"""
# используем когда проинецлизировать ваши ключи каким-то определенным значениями
# пустое создание словаря

b = { }
d = {
    1: 'one',
    2: 'two',
    3: 'theree'
}

# Ключем может быть и цыфры и буквы (списоки нельзя, изменяемый тип): значениями любые типы могут быть произвольные
# Обращаться можно по ключу
    # print(d[2]) # two

# Как добавлять значение
"""
d[4] = 'foir'
d[5] = 'five'
print(b)
d[3] = 'три'# меняем ключ
"""
# Пример где можно применять:
"""
person = {}
s = "ÏVANOV IVAN Samara SGU 5 4 5 5 4 3 5"
s = s.split() # разобьем строчку по пробелам получим список
person['LastName'] = s[0]
person['firsName'] = s[1]
person['city'] = s[2]
person['University'] = s[3]
person['marsk'] = [] # как добавить оценки
for i in s[4:]:
    person['marsk'].append(int(i))

print(person) # {'LastName': 'ÏVANOV', 'firsName': 'IVAN', 'city': 'Samara', 'University': 'SGU', 'marsk': [5, 4, 5, 5, 4, 3, 5]}
"""
# Как удалить один элемент из словаря
    # del d[1] 

# Какие функции поддерживает словарь: 
"""
print(len(d)) # посчитаем сколько пар длина
print(1 in d, 5 in d, 7 not in d) # можем ли проверить есть у нас ключ 1 в словаре
"""
# чтоб избежать ошибки в случает отсвувия ключа
"""
if 5 in d:  # сначало проверить наличе этого ключа. Если 5 то мы к ней обращаемся
    print(d[5])
else: # иначе ее создаем
    d[5] = 'five'
print(d)
"""
# чтоб обратиться к элементу нашего словаря
# for key in d:
    #print(key, d[key])

# МЕТОДЫ ДЛЯ Словаря
# ключем можем быть индефикатор пользователя, значения может быть какие-то данные пользовательские
# пример к англ. буквами добавим значения рус. букв
# .fromkeys - создать словарь в словаре 

# .get - получить значение
"""
print(d.get(1)) 
если нет ключа можно сделать так:
print(d.get(5, 'Нет ключа'))  # можно передавать любре значение, число, список 
"""
# .setdefault - создает новую пару если ее нет, если есть то не чего не произойдет
# print(d.setdefault(4))  # перадаем знач ключа который у нас есть, если 6 то будет non т.к. его нет 
# d.setdefault(6, 'seven') # добавится ключ и значение 
"""
dct = {1: 'one', 2: 'two'}
print(dct[1])
print(dct[3])
"""
# будет только one т.к. оно есть в списке
# но если мы используем get
"""
print(dct.get(1))
print(dct.get(3))
"""
# .popitem() даляет случайное значение из нашего словаря и выводит его
"""
print(d.popitem()) 
"""
# .keys получим значения из нашего словаря
# .items 
"""
print(d.items())
for para in d.items():
    print(para[0], para[1])
"""
# чтоб принять два значения a,b = [4, 7]
"""
for key,value in d.items():
    print(key, value)
"""


# # ошибки не будет и получим one None / безопастный метод получения ключа
# print(dct.get(1, 'Слово не найдено')) # если ключ есть то я получу значение которое там лежит если нет то "Слово не найдено"
# print(dct.get(3, 'Слово не найдено')) # вторым элементом можно указывать значение по умолчанию 

# анологично добавление, если не хотим добавить новое значение по ключу 
# dct = {1: 'one', 2: 'two'}

# #if 2 not in dct: # если 2 не в словаре я выполняю эту операцию. Сюда мы попадет т.к. 2 находится в словаре.


#     #dct[2] = 2222 # по ключу два будет 
# #if 5 not in dct: # если 5 нет в словаре то я выполняю эту операцию
#     #dct[5] = 5555

# # можем заменить встроеным методом 
# dct.setdefault(2, 2222) # () - ключ. Если ключ такой есть он игнорирует
# dct.setdefault(5, 5555) # аналогично . Если не имеется то добавит

# print(dct) # заменится 2ка, а 5 создасться 
# Ответ: {1: 'one', 2: 2222, 5: 5555}

# .pop или del - удаление 
"""
dct.pop(2) # удалить с индектом 2
del dct[2] # так же, но лучше не использваоть 
"""
# Удаление через множества
# s = {1, 2, 3, 4, 5}
# print(s)
# s.discard(2)
# print(s)
# s.discard(7) # не удалить потому что е там и нет
# print(s)
# будет ошибка, но если используем discard все норм
# s.discard удали если есть

# print(a.keys(), a.values(), a.item()) # то что можем вывести ключ, значение, индекс

# ПОДКЛЮЧЕНИЕ МОДЕЛУЙ см файл second

# import second

# теперь можем обращться ко всем имена в этом файле через имя second
# second.f(222)

# КОГДА ПОЛЕЗНО ИСПОЛЬЗОВАТЬ СЛОВАРИ:
"""
1. Подсчет кол-ва обьектов
Например: нам дана строка и нам нужно найти буквы и подсчитать 
2. Словари используются для замены разряженного списка
3. Установить связь между обьектами
4. Хранение данных в обьекте 
"""