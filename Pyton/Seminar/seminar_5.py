# УСКОРЕННАЯ ОБРАБОТКА ДАННЫХ: lambda, filter, map, zip, enumerate, list comprehension

# 1. ДЛЯ ЧЕГО НУЖНА lambda?
print('\n1. ДЛЯ ЧЕГО НУЖНА lambda')

# если хотим использовать функцию один раз и она особо не длиная
# нужна для ситуаций когда функция нужна в качестве аргументов
# Например: у нас есть список картежей точек по оси x и y 
# нам нужно найти максимальное значение по оси х

a = [(1, 2), (7, 1), (6, 1), (6, -4)]

print(max(a)) 
# ответ (6, 1)
# что делать если захотим найти максимальное значение по y ? для этого и нужна лямда
# как ему сказать что искать только по правой стороне по Y 

print(max(a, key=lambda x: x[1])) # если хотим отсортировать по второй если len то получим самое большое значение по длине
# Ответ (3, 3)

a = ['1', '2', '10', '9'] 

print(max(a, key=int)) # переводим строки в инт и находим максимальное
# Ответ (10)

## 2. LIST COMPREHENSION
print('\n2. LIST COMPREHENSION')
# Способ создания списков только для for 
# Например: если хотим заполнить список квадратами
a = []
for n in range(11):
    a.append(n * n)
print(a)

# как сделать тоже самое с помощью LIST COMPREHENSION
b = [n * n for n in range(11)]
print(b)

# как сделать дробные числа
b = [n / 10 for n in range(0, 51, 5)]
print(b)

# не много усложним
# допустим надо надо получить не всех чисел, а только четных
a = []
for n in range(11):
    if n % 2 ==0: # если n остатот от деления равен 0 тогда я его добавляю
        a.append(n * n) # если соотвесвует делаем так
    else: # ** иначе мы добавляем куб
        a.append(n * n * n) # **
print(a)        
      

# теперь тут как будет выглядеть
b = [n * n for n in range(11) if n % 2 ==0] 
# ** если мы что-то делаем в случае ложь (else)
# тогда выглдеть будет так:
c = [n * n if n % 2 ==0 else n * n * n for n in range(11)] # так делаем когда стоит вопрос либо добавлю либо нет
print(c)


# как получить случайное вещественное число
from random import random, randint, randrange # - для целых чисел
print(random() * 100)
# если нам нужно число от 50 до 100
print(50 + random() * 50)
print(randint(50, 100))
print(randrange(50, 101))

# 3. MAP и FILTER - это две похожие операции 
print('\n3. MAP и FILTER')
# map - функция которая принимает какой-то список и производит какие-то дейтсвия над этим списком
# Например:
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
itog = list(map(lambda x: x**2, a)) # map применит к каждому элементу и меняет его коллекции "а", (все элементы списка станут квадртом и вернут число в этом обьекте)
filter_itog = list(filter(lambda x: x % 2 ==0, a)) # фильтр приминимает функцию и если функция дает элемент дает элемент если лож отбрасывает его
# лямда которая принимает от х возращает х % 2 == 0, то данная функция выдаст нам истину

print(itog) # чтоб получить список оборачиваем в лист
print(filter_itog) #так же оборачиваем в лист

# Другой пример:
filter_itog_ = list(filter(lambda x: x % 5 !=0, a)) # останутся только те, которые при деление на 5 дают не ноль
print(filter_itog_)

## Отличие map от фильтров: 
## Map - делает выборку по всем элементам
# filter - делаем выборку по конкретным элементам

## 4. ZIP, ENUMERATE
print('\n4. ZIP, ENUMERATE')
## zip - позволяет нам получить пары из нескольких картежей(обьектов)
# Например:
f_a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
f_b = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i' ] # или 'abcdefghi'
f_c = (False, True, None)

for item in zip(f_a, f_b, f_c):
    print(item) # получим эти троици
## zip берет элемент из каждоый, если какого-то нет элемента то зип завершается
## удобно использовать когда есть очереди сводных сотрудников и очереди задачи
## можно распаковать каждый в свой:
for item_f_a, item_f_b, item_f_c in zip(f_a, f_b, f_c):
    print(item_f_a)
    print(item_f_b)
    print(item_f_c)

## ENUMERATE:
l_b = 'abc'
# for item in l_b: # как мы перебираем элементы
    #print(item)
# можно другим пособом:
for i in range(len(l_b)): # перебираем числа
    print(l_b[i])
# в первом случае получаем доступ к элементам, но не вижу его индекс
# втром не вижу его элемента и чтоб получить идекс надо обраться на прямую
## ENUMERATE - это симбиоз двух этих способов

for i, item in enumerate(l_b):
    print(i, item) # когда мы двигаемся по списки, препочительней использовать 
# Ответ:
# 0 a
# 1 b
# 2 c



